# Do not edit this file directly. It has been autogenerated from
# src\pystuderxcom\api_tcp_async.py
"""xcom_api.py: communication api to Studer Xcom via LAN."""

import asyncio
import binascii
import logging
import socket

from datetime import datetime, timedelta
from typing import Iterable


from .api_base_async import (
    AsyncXcomApiBase,
    XcomApiWriteException,
    XcomApiReadException,
    XcomApiTimeoutException,
    XcomApiUnpackException,
    XcomApiResponseIsError,
    START_TIMEOUT,
    STOP_TIMEOUT,
    REQ_TIMEOUT,
)
from .api_base_sync import (
    XcomApiBase
)
from .const import (
    ScomAddress,
    XcomLevel,
    XcomFormat,
    XcomCategory,
    XcomAggregationType,
    ScomObjType,
    ScomObjId,
    ScomService,
    ScomQspId,
    ScomErrorCode,
    XcomParamException,
    safe_len,
)
from .data import (
    XcomData,
    XcomDataMessageRsp,
    MULTI_INFO_REQ_MAX,
)
from .factory_async import (
    AsyncXcomFactory,
)
from .factory_sync import (
    XcomFactory,
)
from .families import (
    XcomDeviceFamilies
)
from .messages import (
    XcomMessage,
)
from .protocol import (
    XcomPackage,
)
from .values import (
    XcomValues,
    XcomValuesItem,
)
import io
import threading


_LOGGER = logging.getLogger(__name__)


DEFAULT_PORT = 4001


##
## Class implementing Xcom-LAN TCP network protocol
##
class XcomApiTcp(XcomApiBase):

    def __init__(self, port=DEFAULT_PORT):
        """
        MOXA is connecting to the TCP Server we are creating here.
        Once it is connected we can send package requests.
        """
        super().__init__()

        self.localPort = port
        self._server = None
        self._connection = None
        self._started = False
        self._connected = False
        self._remote_ip = None

        self._sendPackageLock = threading.Lock() # to make sure _sendPackage is never called concurrently


    def start(self, timeout=START_TIMEOUT, wait_for_connect=True) -> bool:
        """
        Start the Xcom Server and listening to the Xcom client.
        """
        if not self._started:
            _LOGGER.info(f"Xcom TCP server start listening on port {self.localPort}")

            self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server.bind(("", self.localPort))
            self.server.listen(1)
            self._started = True

            if wait_for_connect:
                self.wait_until_connected()
        else:
            _LOGGER.info(f"Xcom TCP server already listening on port {self.localPort}")
        
        return True


    def wait_until_connected(self):
        _LOGGER.info("Waiting for MOXA to connect...")

        conn, addr = self.server.accept()

        _LOGGER.debug(f"Got connection from {addr}")
        self._connected = True
        self._connection = conn        
        self._remote_ip = addr[0]


    def stop(self):
        """
        Stop listening to the the Xcom Client and stop the Xcom Server.
        """
        _LOGGER.info(f"Stopping Xcom TCP server")
        try:
            if self._connection is not None:
                self._connection.close()

        except Exception as e:
           _LOGGER.warning(f"Exception during closing of tcp connection: {e}")

        try:
            if self._server is not None:
                self._server.close()

        except Exception as e:
           _LOGGER.warning(f"Exception during closing of tcp server: {e}")

        self._connected = False
        self._started = False
        _LOGGER.info(f"Stopped Xcom TCP server")
    

    def _sendPackage(self, request: XcomPackage, timeout=REQ_TIMEOUT, verbose=False) -> XcomPackage | None:
        """
        Send an Xcom package from Server to Client and wait for the response (or timeout).
        Throws:
            XcomApiWriteException
            XcomApiReadException
            XcomApiTimeoutException
        """
        if not self._connected:
            _LOGGER.warning(f"_sendPackage - not connected")
            return None
        
        with self._sendPackageLock:
            # Send the request package to the Xcom client
            try:
                data = request.getBytes()
                if verbose:
                    _LOGGER.debug(f"send {len(data)} bytes ({binascii.hexlify(data).decode('ascii')}), decoded: {request}")

                self._connection.send(data)

            except Exception as e:
                msg = f"Exception while sending request package to Xcom client: {e}"
                raise XcomApiWriteException(msg) from None

            # Receive packages until we get the one we expect
            try:
                while True:
                    data = self._connection.recv(XcomPackage.max_length)
                    response = XcomFactory.parse_package_bytes(data)

                    if response.isResponse() and \
                       response.frame_data.service_id == request.frame_data.service_id and \
                       response.frame_data.service_data.object_id == request.frame_data.service_data.object_id and \
                       response.frame_data.service_data.property_id == request.frame_data.service_data.property_id:

                        # Yes, this is the answer to our request
                        if verbose:
                            _LOGGER.debug(f"recv {len(data)} bytes ({binascii.hexlify(data).decode('ascii')}), decoded: {response}")
                        return response
                    
                    else:
                        # No, not an answer to our request, continue loop for next answer (or timeout)
                        if verbose:
                            _LOGGER.debug(f"skip {len(data)} bytes ({binascii.hexlify(data).decode('ascii')}), decoded: {response}")

            except Exception as e:
                msg = f"Exception while listening for response package from Xcom client: {e}"
                raise XcomApiReadException() from None

